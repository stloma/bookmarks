{"version":3,"sources":["../../../src/server/models/db.js"],"names":["MongoDBStore","store","uri","collection","on","error","db","connect","then","connection","bookmarkDb","catch","console","log","getBookmarks","userDb","bookmarks","find","toArray","result","map","bookmark","tags","join","split","tagcount","Object","keys","value","tag","count","filter","name","records","Error","discover","collections","listCollections","ids","startsWith","endsWith","promises","id","Promise","all","allBookmarks","concat","counts","addBookmark","newBookmark","userId","res","insertOne","favicon","_id","insertedId","url","findOne","username","createdBy","updateOne","$set","deleteBookmark","deleteOne","n","editBookmark","site","bookmarkId","comment","update","updated"],"mappings":"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","file":"db.js","sourcesContent":["import session from 'express-session'\nimport { MongoClient, ObjectId } from 'mongodb'\nimport connectMongo from 'connect-mongodb-session'\nimport { countBy } from 'lodash'\nimport download from '../scripts/favicon'\n\nconst MongoDBStore = connectMongo(session)\n\nconst store = new MongoDBStore(\n  {\n    uri: 'mongodb://localhost/bookmarkapp',\n    collection: 'sessions'\n  })\n\nstore.on('error', (error) => {\n  if (error) throw error\n})\n\nconst db = {}\n\nMongoClient.connect('mongodb://localhost/bookmarkapp')\n  .then((connection) => {\n    db.bookmarkDb = connection\n  })\n  .catch((error) => {\n    console.log(`Mongo connect error: ${error}`)\n  })\n\nasync function getBookmarks(userDb) {\n  try {\n    // Get user bookmarks\n    const bookmarks = await db.bookmarkDb.collection(`bookmarks.${userDb}`).find().toArray()\n\n    // Tally up tag counts for tagcloud\n    const result = countBy(bookmarks.map(bookmark => bookmark.tags).join(' ').split(' '))\n\n    const tagcount = Object.keys(result).map(tag => ({ value: tag, count: result[tag] }))\n      .filter(name => name.value !== '')\n\n    return ({ tagcount, records: bookmarks })\n  } catch (error) { throw Error(error) }\n}\n\nasync function discover(userDb) {\n  try {\n    // Get all collections\n    const collections = await db.bookmarkDb.listCollections().toArray()\n\n    // Filter out all bookmark collections that don't belong to the current user\n    const ids = collections.filter(\n      collection => collection.name.startsWith('bookmarks') && !collection.name.endsWith(userDb)\n    )\n\n    // Get an array of promises\n    const promises = ids.map(id => db.bookmarkDb.collection(id.name).find().toArray())\n\n    // Resolve all promises\n    const result = await Promise.all(promises)\n\n    // Create one array from the array of users' bookmarks\n    const allBookmarks = [].concat(...result)\n\n    // Count tags for tagcloud\n    const counts = countBy(allBookmarks.map(bookmark => bookmark.tags).join(' ').split(' '))\n\n    const tagcount = Object.keys(counts).map(tag => ({ value: tag, count: counts[tag] }))\n      .filter(name => name.value !== '')\n\n    return { tagcount, records: allBookmarks }\n  } catch (error) { throw Error(error) }\n}\n\nasync function addBookmark(userDb, bookmark) {\n  try {\n    const newBookmark = bookmark\n    const userId = userDb.split('.')[1]\n\n    const res = await db.bookmarkDb.collection(userDb).insertOne(newBookmark)\n\n    // if this is a new bookmark, download favicon and add createdby property\n    if (!newBookmark.favicon) {\n      // Download favicon\n      const _id = new ObjectId(res.insertedId)\n      const result = await download(newBookmark.url, _id)\n\n      // If the fetch result of the favicon was not 200, use the default image\n      newBookmark.favicon = result === 200 ? `${_id}.ico` : 'default-favicon.png'\n\n      // Add created by property to bookmarks for /discover\n      const name = await db.bookmarkDb.collection('users').findOne({ _id: new ObjectId(userId) }, { _id: 0, username: 1 })\n      newBookmark.createdBy = name.username\n      await db.bookmarkDb.collection(userDb).updateOne(\n        { _id },\n        { $set: { favicon: newBookmark.favicon, createdBy: newBookmark.createdBy } }\n      )\n    }\n  } catch (error) { throw Error(error) }\n}\n\nasync function deleteBookmark(userDb, _id) {\n  const result = await db.bookmarkDb.collection(userDb).deleteOne({ _id })\n\n  // If bookmark doesn't exist, return 404\n  const error = result.result.n === 1 ? null : 404\n\n  if (error) throw new Error(error)\n\n  return result\n}\n\nasync function editBookmark(userDb, site) {\n  const bookmarkId = new ObjectId(site._id)\n\n  try {\n    await db.bookmarkDb.collection(userDb).updateOne(\n      { _id: bookmarkId },\n      { $set: {\n        name: site.name,\n        url: site.url,\n        comment: site.comment,\n        tags: site.tags,\n        update: site.updated\n      } }\n    )\n  } catch (error) { throw Error(error) }\n}\n\nexport { discover, db, store, addBookmark, getBookmarks, deleteBookmark, editBookmark }\n"]}