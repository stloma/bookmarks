{"version":3,"sources":["../../../src/server/models/db.js"],"names":["userDb","bookmarks","db","bookmarkDb","collection","find","toArray","result","countBy","map","bookmark","tags","join","split","tagcount","Object","keys","value","tag","count","records","error","Error","getBookmarks","collections","listCollections","ids","filter","name","startsWith","endsWith","promises","id","Promise","all","allBookmarks","concat","counts","discover","newBookmark","userId","res","insertOne","favicon","_id","ObjectId","insertedId","download","url","findOne","username","createdBy","updateOne","$set","addBookmark","deleteOne","n","deleteBookmark","site","bookmarkId","comment","update","updated","editBookmark","session","MongoClient","connectMongo","MongoDBStore","store","uri","on","connect","then","connection","catch","console","log"],"mappings":"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","file":"db.js","sourcesContent":["import session from 'express-session';\nimport { MongoClient, ObjectId } from 'mongodb';\nimport connectMongo from 'connect-mongodb-session';\nimport { countBy } from 'lodash';\nimport { download } from '../scripts/favicon';\n\nconst MongoDBStore = connectMongo(session);\n\nconst store = new MongoDBStore(\n  {\n    uri: 'mongodb://localhost/bookmarkapp',\n    collection: 'sessions'\n  });\n\nstore.on('error', (error) => {\n  if (error) throw error;\n});\n\nconst db = {};\n\nMongoClient.connect('mongodb://localhost/bookmarkapp')\n  .then((connection) => {\n    db.bookmarkDb = connection;\n  })\n  .catch((error) => {\n    console.log(`Mongo connect error: ${error}`);\n  });\n\nasync function getBookmarks(userDb) {\n  try {\n    // Get user bookmarks\n    const bookmarks = await db.bookmarkDb.collection(`bookmarks.${userDb}`).find().toArray();\n\n    // Tally up tag counts for tagcloud\n    const result = countBy(bookmarks.map(bookmark => bookmark.tags).join(' ').split(' '));\n    const tagcount = Object.keys(result).map(tag => ({ value: tag, count: result[tag] }));\n\n    return ({ tagcount, records: bookmarks });\n  } catch (error) { throw Error(error); }\n}\n\nasync function discover(userDb) {\n  try {\n    // Get all collections\n    const collections = await db.bookmarkDb.listCollections().toArray();\n\n    // Filter out all bookmark collections that don't belong to the current user\n    const ids = collections.filter(\n      collection => collection.name.startsWith('bookmarks') && !collection.name.endsWith(userDb)\n    );\n\n    // Get an array of promises\n    const promises = ids.map(id => db.bookmarkDb.collection(id.name).find().toArray());\n\n    // Resolve all promises\n    const result = await Promise.all(promises);\n\n    // Create one array from the array of users' bookmarks\n    const allBookmarks = [].concat(...result);\n\n    // Count tags for tagcloud\n    const counts = countBy(allBookmarks.map(bookmark => bookmark.tags).join(' ').split(' '));\n    const tagcount = Object.keys(counts).map(tag => ({ value: tag, count: result[tag] }));\n\n    return { tagcount, records: allBookmarks };\n  } catch (error) { throw Error(error); }\n}\n\nasync function addBookmark(userDb, bookmark) {\n  try {\n    const newBookmark = bookmark;\n    const userId = userDb.split('.')[1];\n\n    const res = await db.bookmarkDb.collection(userDb).insertOne(newBookmark);\n\n    // if this is a new bookmark, download favicon and add createdby property\n    if (!newBookmark.favicon) {\n      // Download favicon\n      const _id = new ObjectId(res.insertedId);\n      const result = await download(newBookmark.url, _id);\n\n      // If the fetch result of the favicon was not 200, use the default image\n      newBookmark.favicon = result === 200 ? `${_id}.ico` : 'default-favicon.png';\n\n      // Add created by property to bookmarks for /discover\n      const name = await db.bookmarkDb.collection('users').findOne({ _id: new ObjectId(userId) }, { _id: 0, username: 1 });\n      newBookmark.createdBy = name.username;\n      await db.bookmarkDb.collection(userDb).updateOne(\n        { _id },\n        { $set: { favicon: newBookmark.favicon, createdBy: newBookmark.createdBy } }\n      );\n    }\n  } catch (error) { throw Error(error); }\n}\n\nasync function deleteBookmark(userDb, _id) {\n  const result = await db.bookmarkDb.collection(userDb).deleteOne({ _id });\n\n  // If bookmark doesn't exist, return 404\n  const error = result.result.n === 1 ? null : 404;\n\n  if (error) throw new Error(error);\n\n  return result;\n}\n\nasync function editBookmark(userDb, site) {\n  const bookmarkId = new ObjectId(site._id);\n\n  try {\n    await db.bookmarkDb.collection(userDb).updateOne(\n      { _id: bookmarkId },\n      { $set: {\n        name: site.name,\n        url: site.url,\n        comment: site.comment,\n        tags: site.tags,\n        update: site.updated\n      } }\n    );\n  } catch (error) { throw Error(error); }\n}\n\nexport { discover, db, store, addBookmark, getBookmarks, deleteBookmark, editBookmark };\n"]}